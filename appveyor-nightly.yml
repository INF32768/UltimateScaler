version: $(VERSION)-alpha (#{build})
skip_tags: true
environment:
  JAVA_HOME: C:\Program Files\Java\jdk21
  GITHUB_TOKEN:
    secure: tUvjufRIPG6IV4pB9jRiNUfgD/Heb1TiwBkYJZvnfSOjDqoTu6d843oxOfZdTxsV #有效期至2026-05-28
  PROJECT_NAME: ultimatescaler-nightly
  VERSION: 0.4.0-1.21.2
  DEPLOYMENT_LINK: "https://github.com/INF32768/UltimateScaler/releases/tag/nightly"
cache:
  - C:\Users\appveyor\.gradle\caches\fabric-loom
  - C:\Users\appveyor\.gradle\caches\modules-2
install:
  - ps: "$ErrorActionPreference = \"Stop\"\n function Write-Log {\n param([string]$Message)\n $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n Write-Host \"[$timestamp] $Message\"\n }\n function Invoke-GitHubAPI {\n param(\n   [string]$Endpoint,\n   [string]$Method = \"GET\"\n )\n \n $headers = @{\n   \"Authorization\" = \"token $env:GITHUB_TOKEN\"\n   \"Accept\" = \"application/vnd.github.v3+json\"\n   \"User-Agent\" = \"PowerShell-CI-Script\"\n }\n \n try {\n   $response = Invoke-RestMethod -Uri \"https://api.github.com/$Endpoint\" `\n   -Method $Method `\n   -Headers $headers `\n   -ContentType \"application/json\"\n   return $response\n }\n catch {\n   Write-Log \"GitHub API调用失败: $($_.Exception.Message)\"\n   exit 1\n }\n }\n if ($env:APPVEYOR_REPO_TAG -eq \"true\") {\n Write-Log \"检测到标签触发: $env:APPVEYOR_REPO_TAG_NAME，跳过每日构建\"\n Exit-AppVeyorBuild\n return\n }\n Write-Log \"开始构建前验证...\"\n Write-Log \"查询GitHub仓库分支...\"\n $branches = Invoke-GitHubAPI -Endpoint \"repos/$env:APPVEYOR_REPO_NAME/branches\"\n $targetBranches = $branches | Where-Object {\n $_.name -eq \"main\" -or \n $_.name -match \"^feat/\" -or \n $_.name -match \"^fix/\" -or \n $_.name -match \"^refactor/\" -or \n $_.name -match \"^perf/\"\n }\n if ($targetBranches.Count -eq 0) {\n Write-Log \"未找到目标分支\"\n exit 1\n }\n $latestBranch = $null\n $latestCommitDate = [DateTime]::MinValue\n foreach ($branch in $targetBranches) {\n $commit = Invoke-GitHubAPI -Endpoint \"repos/$env:APPVEYOR_REPO_NAME/commits/$($branch.commit.sha)\"\n $commitDate = [DateTime]$commit.commit.committer.date\n if ($commitDate -gt $latestCommitDate) {\n   $latestCommitDate = $commitDate\n   $latestBranch = $branch\n }\n }\n if (-not $latestBranch) {\n Write-Log \"无法确定最新分支\"\n exit 1\n }\n Write-Log \"选择分支: $($latestBranch.name) (最新提交: $latestCommitDate)\"\n $currentSha = $latestBranch.commit.sha\n Write-Log \"当前最新提交SHA: $currentSha\"\n $env:CI_TARGET_BRANCH = $latestBranch.name\n $env:CI_TARGET_SHA = $currentSha\n Write-Log \"构建验证通过，开始处理分支: $($latestBranch.name)\"\n if ($latestBranch.name -eq \"main\") {\n Write-Log \"目标分支为main，无需签出\"\n }\n else {\n Write-Log \"签出到分支: $($latestBranch.name)\"\n git checkout -q $latestBranch.name\n }\n $buildDate = Get-Date -Format \"yyyyMMdd\"\n $shortSha = $currentSha.Substring(0, 8)\n $nightlyFileName = \"{0}-{1}-{2}-{3}.jar\" -f $env:PROJECT_NAME, $env:VERSION, $buildDate, $shortSha\n $env:NIGHTLY_FILENAME = $nightlyFileName\n Write-Log \"设置构建产物文件名: $nightlyFileName\"\n Write-Log \"构建前准备完成，开始构建...\""
build_script:
  - cmd: >-
      gradlew build --no-daemon
after_build:
  - ps: "$ErrorActionPreference = \"Stop\"\n function Write-Log {\n param([string]$Message)\n $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n Write-Host \"[$timestamp] $Message\"\n }\n Write-Log \"开始重命名构建产物...\"\n if (-not $env:NIGHTLY_FILENAME) {\n Write-Log \"错误: NIGHTLY_FILENAME 环境变量未设置\"\n exit 1\n }\n if (-not $env:PROJECT_NAME -or -not $env:VERSION) {\n Write-Log \"错误: PROJECT_NAME 或 VERSION 环境变量未设置\"\n exit 1\n }\n $sourceDir = \"build\\libs\"\n $originalFileName = \"{0}-{1}.jar\" -f $env:PROJECT_NAME, $env:VERSION\n $sourceFilePath = Join-Path $sourceDir $originalFileName\n $targetFilePath = Join-Path $sourceDir $env:NIGHTLY_FILENAME\n if (-not (Test-Path $sourceFilePath)) {\n Write-Log \"警告: 原始文件不存在: $sourceFilePath\"\n $possibleFiles = Get-ChildItem -Path $sourceDir -Filter \"*.jar\" | Where-Object {\n   $_.Name -match \"^$([regex]::Escape($env:PROJECT_NAME))-$([regex]::Escape($env:VERSION))\"\n }\n if ($possibleFiles.Count -eq 0) {\n   Write-Log \"错误: 未找到任何匹配的构建产物\"\n   exit 1\n }\n $mainJar = $possibleFiles | Where-Object { $_.Name -match \"^$([regex]::Escape($env:PROJECT_NAME))-$([regex]::Escape($env:VERSION))\\.jar$\" }\n if ($mainJar) {\n   $sourceFilePath = $mainJar.FullName\n   Write-Log \"找到主JAR文件: $sourceFilePath\"\n }\n else {\n   $sourceFilePath = $possibleFiles[0].FullName\n   Write-Log \"使用找到的JAR文件: $sourceFilePath\"\n }\n }\n if (-not (Test-Path $sourceDir)) {\n Write-Log \"错误: 构建目录不存在: $sourceDir\"\n exit 1\n }\n try {\n Write-Log \"重命名文件:\"\n Write-Log \"  从: $(Split-Path $sourceFilePath -Leaf)\"\n Write-Log \"  到: $(Split-Path $targetFilePath -Leaf)\"\n if (Test-Path $targetFilePath) {\n   Remove-Item -Path $targetFilePath -Force\n   Write-Log \"已删除已存在的目标文件\"\n }\n Rename-Item -Path $sourceFilePath -NewName $env:NIGHTLY_FILENAME -Force\n Write-Log \"文件重命名成功\"\n $symlinkPath = Join-Path $sourceDir $originalFileName\n if (-not (Test-Path $symlinkPath)) {\n   try {\n New-Item -ItemType SymbolicLink -Path $symlinkPath -Target $targetFilePath -Force | Out-Null\n Write-Log \"已创建符号链接: $originalFileName -> $env:NIGHTLY_FILENAME\"\n   }\n   catch {\n Write-Log \"警告: 无法创建符号链接: $_\"\n   }\n }\n $env:NIGHTLY_FILE_PATH = $targetFilePath\n Write-Log \"设置文件路径变量: $targetFilePath\"\n }\n catch {\n Write-Log \"重命名文件失败: $($_.Exception.Message)\"\n exit 1\n }\n Write-Log \"打包前处理完成\""
artifacts:
  - path: $(NIGHTLY_FILE_PATH)
    name: UltimateScaler.jar
deploy_script:
  - ps: "$ErrorActionPreference = \"Stop\"\n\n  function Write-Log {\n  param([string]$Message)\n  $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss\"\n  Write-Host \"[$timestamp] $Message\"\n  }\n\n  function Invoke-GitHubAPI {\n  param(\n  [string]$Endpoint,\n  [string]$Method = \"GET\",\n  [object]$Body = $null,\n  [string]$ContentType = \"application/json\"\n  )\n\n  $headers = @{\n  \"Authorization\" = \"token $env:GITHUB_TOKEN\"\n  \"Accept\" = \"application/vnd.github.v3+json\"\n  \"User-Agent\" = \"PowerShell-CI-Script\"\n  }\n\n  try {\n  $params = @{\n  Uri = \"https://api.github.com/$Endpoint\"\n  Method = $Method\n  Headers = $headers\n  ContentType = $ContentType\n  }\n\n  if ($Body) {\n  if ($ContentType -eq \"application/json\" -and $Body -isnot [string]) {\n  $params.Body = $Body | ConvertTo-Json -Depth 10 -Compress\n  }\n  else {\n  $params.Body = $Body\n  }\n  }\n\n  $response = Invoke-RestMethod @params\n  return $response\n  }\n  catch {\n  $errorDetails = $_.Exception.Message\n  try {\n  $responseStream = $_.Exception.Response.GetResponseStream()\n  if ($responseStream) {\n  $reader = New-Object System.IO.StreamReader($responseStream)\n  $errorBody = $reader.ReadToEnd()\n  $reader.Close()\n  $errorDetails += \" - Response: $errorBody\"\n  }\n  }\n  catch {}\n\n  Write-Log \"GitHub API调用失败 ($Method $Endpoint): $errorDetails\"\n  throw\n  }\n  }\n\n  function UploadToRelease {\n  param(\n  [string]$ReleaseUrl,\n  [string]$FilePath,\n  [string]$AssetName\n  )\n\n  Write-Log \"开始上传文件: $AssetName\"\n\n  if ($ReleaseUrl -match \"releases/tag/([^/]+)$\") {\n  $tagName = $matches[1]\n  $releaseInfo = Invoke-GitHubAPI -Endpoint \"repos/$env:APPVEYOR_REPO_NAME/releases/tags/$tagName\"\n  $releaseId = $releaseInfo.id\n  }\n  elseif ($ReleaseUrl -match \"releases/(\\d+)$\") {\n  $releaseId = $matches[1]\n  }\n  else {\n  throw \"无法从Release链接提取ID: $ReleaseUrl\"\n  }\n\n  if (-not (Test-Path $FilePath)) {\n  throw \"文件不存在: $FilePath\"\n  }\n\n  $uploadUrl = \"https://uploads.github.com/repos/$env:APPVEYOR_REPO_NAME/releases/$releaseId/assets\"\n  $queryParams = \"?name=$([System.Web.HttpUtility]::UrlEncode($AssetName))\"\n\n  $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)\n\n  $extension = [System.IO.Path]::GetExtension($AssetName).ToLower()\n  $contentType = switch ($extension) {\n  \".jar\" { \"application/java-archive\" }\n  \".zip\" { \"application/zip\" }\n  \".tar.gz\" { \"application/gzip\" }\n  \".exe\" { \"application/x-msdownload\" }\n  \".dmg\" { \"application/x-apple-diskimage\" }\n  default { \"application/octet-stream\" }\n  }\n\n  $headers = @{\n  \"Authorization\" = \"token $env:GITHUB_TOKEN\"\n  \"Accept\" = \"application/vnd.github.v3+json\"\n  \"Content-Type\" = $contentType\n  }\n\n  try {\n  Write-Log \"上传文件到: $uploadUrl$queryParams\"\n  $response = Invoke-RestMethod -Uri \"$uploadUrl$queryParams\" `\n    -Method POST `\n    -Headers $headers `\n    -Body $fileBytes `\n    -ContentType $contentType\n  Write-Log \"文件上传成功: $($response.name) ($($response.size) bytes)\"\n  return $response\n  }\n  catch {\n  Write-Log \"文件上传失败: $($_.Exception.Message)\"\n  throw\n  }\n  }\n\n  function Remove-ReleaseAsset {\n  param(\n  [string]$AssetId\n  )\n\n  try {\n  Write-Log \"删除资产: $AssetId\"\n  Invoke-GitHubAPI -Endpoint \"repos/$env:APPVEYOR_REPO_NAME/releases/assets/$AssetId\" -Method DELETE\n  Write-Log \"资产删除成功\"\n  }\n  catch {\n  Write-Log \"资产删除失败: $($_.Exception.Message)\"\n  }\n  }\n\n  Write-Log \"开始部署处理...\"\n\n  if (-not (Test-Path $env:NIGHTLY_FILE_PATH)) {\n  Write-Log \"错误: 构建产物文件不存在: $env:NIGHTLY_FILE_PATH\"\n  exit 1\n  }\n\n  Write-Log \"部署配置:\"\n  Write-Log \"  Release链接: $env:DEPLOYMENT_LINK\"\n  Write-Log \"  目标分支: $env:CI_TARGET_BRANCH\"\n  Write-Log \"  构建产物: $env:NIGHTLY_FILE_PATH\"\n\n  Write-Log \"获取Release信息...\"\n  try {\n  if ($env:DEPLOYMENT_LINK -match \"github\\.com/([^/]+/[^/]+)/releases\") {\n  $repoPath = $matches[1]\n  if ($repoPath -ne $env:APPVEYOR_REPO_NAME) {\n  Write-Log \"警告: Release链接的仓库 ($repoPath) 与当前仓库 ($env:APPVEYOR_REPO_NAME) 不匹配\"\n  }\n  }\n\n  $releaseUrl = $env:DEPLOYMENT_LINK\n  if ($releaseUrl -match \"releases/tag/([^/]+)$\") {\n  $tagName = $matches[1]\n  $release = Invoke-GitHubAPI -Endpoint \"repos/$env:APPVEYOR_REPO_NAME/releases/tags/$tagName\"\n  }\n  else {\n  $release = Invoke-GitHubAPI -Endpoint \"repos/$env:APPVEYOR_REPO_NAME/releases/latest\"\n  }\n\n  $releaseId = $release.id\n  $assets = $release.assets\n\n  Write-Log \"找到Release: $($release.name) (ID: $releaseId)\"\n  Write-Log \"当前资产数量: $($assets.Count)\"\n  }\n  catch {\n  Write-Log \"获取Release信息失败: $($_.Exception.Message)\"\n  exit 1\n  }\n\n  Write-Log \"清理旧的分支构建产物...\"\n  $branchPrefix = $env:CI_TARGET_BRANCH -replace '[^a-zA-Z0-9._-]', '_'\n  $deletedCount = 0\n\n  foreach ($asset in $assets) {\n  $assetName = $asset.name\n  if ($assetName -like \"$branchPrefix*\") {\n  Write-Log \"找到需要删除的旧文件: $assetName\"\n  try {\n  Remove-ReleaseAsset -AssetId $asset.id\n  $deletedCount++\n  }\n  catch {\n  Write-Log \"删除文件失败: $assetName - $_\"\n  }\n  }\n  }\n\n  Write-Log \"清理完成，删除了 $deletedCount 个旧文件\"\n\n  $originalFileName = [System.IO.Path]::GetFileName($env:NIGHTLY_FILE_PATH)\n  $branchSafeName = $env:CI_TARGET_BRANCH -replace '[^a-zA-Z0-9._-]', '_'\n  $newAssetName = \"$branchSafeName-$originalFileName\"\n\n  Write-Log \"新文件名: $newAssetName\"\n\n  $tempDir = Join-Path $env:TEMP \"github-deploy-$(Get-Date -Format 'yyyyMMddHHmmss')\"\n  New-Item -ItemType Directory -Path $tempDir -Force | Out-Null\n\n  $tempFilePath = Join-Path $tempDir $newAssetName\n  try {\n  Write-Log \"创建临时副本: $tempFilePath\"\n  Copy-Item -Path $env:NIGHTLY_FILE_PATH -Destination $tempFilePath -Force\n\n  if (-not (Test-Path $tempFilePath)) {\n  throw \"文件复制失败\"\n  }\n\n  $fileSize = (Get-Item $tempFilePath).Length\n  Write-Log \"文件复制成功，大小: $fileSize bytes\"\n  }\n  catch {\n  Write-Log \"创建临时副本失败: $($_.Exception.Message)\"\n  if (Test-Path $tempDir) {\n  Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue\n  }\n  exit 1\n  }\n\n  try {\n  Write-Log \"开始上传文件到GitHub Release...\"\n  $uploadResult = UploadToRelease -ReleaseUrl $env:DEPLOYMENT_LINK `\n   -FilePath $tempFilePath `\n   -AssetName $newAssetName\n  Write-Log \"上传成功!\"\n  Write-Log \"文件URL: $($uploadResult.browser_download_url)\"\n  Write-Log \"文件大小: $($uploadResult.size) bytes\"\n\n  $env:DEPLOYED_FILE_URL = $uploadResult.browser_download_url\n  $env:DEPLOYED_FILE_NAME = $newAssetName\n  $exitCode = 0\n  }\n  catch {\n  Write-Log \"上传失败: $($_.Exception.Message)\"\n    $exitCode = 1\n  }\n  finally {\n  Write-Log \"清理临时文件...\"\n  if (Test-Path $tempDir) {\n  Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue\n  Write-Log \"临时目录已清理\"\n  }\n  }\n\n  if ($exitCode -eq 0) {\n  Write-Log \"部署完成!\"\n  }\n  else {\n  Write-Log \"部署失败\"\n  exit $exitCode\n  }"